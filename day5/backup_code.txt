(* Find the coordinates at which two line segments intersect/overlap *)
let find_intersects line1 line2 =    
    match line1 line2 with
    | line1.angle = line2.angle && 
      ( (line1.angle = Vert && line1.x1 = line2.x1) or 
        (line1.angle = Horz && line1.y1 = line2.y1) ) -> 
        (* Lines are paralell and overlap *)
        match line1 line2 with
        | line1.angle = Vert ->
            let overlap_start = max line1.y1 line2.y1 in
            let overlap_end = max line1.y2 line2.y2 in
            
        | line1.angle = Horz ->
            let overlap_start = max line1.x1 line2.x1 in
            let overlap_end = max line1.x2 line2.x2 in

    | (line1.angle = Vert &&
       line2.x1 < line1.x1 < line2.x2) or 
      (line2.angle = Vert &&
       line1.x1 < line2.x1 < line1.x2) ->
       (* Lines are orthogonal and overlap *)

(***************************************)


let input_all_lines file =
    let rec build_list ic lines =
        match input_line ic with
        | exception End_of_file -> lines
        | line -> build_list ic (line::lines)
    in
    let ic = open_in file in
    let result = build_list ic [] in
    List.rev result

module String = struct
    include String
    let split_on_str delim str = Str.split (Str.regexp delim) str
    (*let lsplit2_exn = Base.String.lsplit2_exn*)
end

type line_seg_t =
    { x1 : int; (* Start X-coord *) 
      y1 : int; (* Start Y-coord *)
      x2 : int; (* End X-coord *)
      y2 : int; (* End Y-coord *)
      angle : angle_t } (* Whether it's vertical, horizontal or diagonal *)

type angle_t
    | Diag -> 0 (* Diagonal *)
    | Vert -> 1 (* Vertical *)
    | Horz -> 2 (* Horizontal *)

(*********************************************)

(*let fold_permutations init list =
*)

let parse_angle x1 y1 x2 y2 =
    match x1 y1 x2 y2 with
    | x1 = x2 -> Vert (* Line is vertical *)
    | y1 = y2 -> Horz (* Line is horizontal *)
    | _ -> Diag

let parse_line_seg line_seg =
    (*let re = Str.regexp "\\(\\d+\\),\\(\\d+\\) -> \\(\\d+\\),\\(\\d+\\)"
    Str.string_match re line_seg*)

    (*let start_coord, end_coord = String.lsplit2_exn " <- " line_seg in
    let x1, y1 = String.lsplit2_exn "," start_coord in
    let x2, y2 = String.lsplit2_exn "," end_coord in*)

    let [start_coord; end_coord] = String.split_on_str " -> " line_seg in
    let [x1; y1] = String.split_on_char ',' start_coord in
    let [x2; y2] = String.split_on_char ',' end_coord in
    let angle = parse_angle x1 y1 x2 y2 in 
    { x1 = x1; x2 = x2; y1 = y1; y2 = y2; angle = angle}

(* Only keep orthogonal lines (Vertical and horizontal lines) *)
let rec parse_and_filter_lines lines new_lines =
    match lines with
    | [] -> List.rev new_lines
    | line::rem_lines ->
        let line_seg = parse_line_seg line in
        if line_seg.angle > 0 then
            filter_lines rem_lines (line_seg :: new_lines)

let get_coords 

let get_coords start _end =
    let rec vertical_walk y new_coords=
        match y with
        | y = line_seg.y2 -> new_coords
        | _ -> vertical_walk (y+1) ((line_seg.x1, y+1) :: new_coords)
    in
    let rec horizontal_walk x new_coords =
        match x with
        | x = line_seg.x2 -> new_coords
        | _ -> vertical_walk (y+1) ((line_seg.x1, y+1) :: new_coords)
    in

    match line_seg.angle with
    | Diag -> print_string "get_coords Not implemented for Diagonal";[]
    | Vert ->
        for y = line_seg.y1 to line_seg.y2 do

        done
    | Horz 

(* Find the coordinates at which two line segments intersect/overlap *)
let find_intersects line1 line2 =    
    match line1 line2 with
    | line1.angle = line2.angle -> 
        (* Lines are paralell *)
        match line1 line2 with
        | line1.angle = Vert ->
            let overlap_start = max line1.y1 line2.y1 in
            let overlap_end = max line1.y2 line2.y2 in
            
        | line1.angle = Horz ->
            let overlap_start = max line1.x1 line2.x1 in
            let overlap_end = max line1.x2 line2.x2 in

    | (line1.angle = Vert &&
       line2.x1 < line1.x1 < line2.x2) or 
      (line2.angle = Vert &&
       line1.x1 < line2.x1 < line1.x2) ->
       (* Lines are orthogonal and overlap *)

let part1 lines =
    let orthog_line_segs = parse_and_filter_lines lines in

let () = 
    let lines = input_all_lines "input.txt" in
    part1 lines

(************************************************ *)

    (* Based on the 'fold'/'fold_left' function, except it
       works backwards, starting only from a initial value
       that is used to build up a list of elements of the
       same type as 'init'.
       The function 'f' returns a tuple consisting of:
       1. Value appended to the resulting list and 
          used as the input to the next call to 'f',
          as long as the 2nd element in the tuple is
          true.
       2. Bool, this is the stop condition, determining
          when the "fold_build" call should end.
          Stops when this is set to false.
    *)
    let fold_build init f = 
        let rec inner accu accu_list =
            let new_accu, continue = f accu in
            if continue then
                inner new_accu (new_accu :: accu_list)
            else
                accu_list
        inner init

(******************************************************************** *)



    (* Based on the 'fold'/'fold_left' function, except it
       works backwards, starting only from a initial value
       that is used to build up a list of elements of the
       same type as 'init'.
       The value returned by function 'f' is appended to
       a list that is returned as a result. The function
       'fold_build' stops when 'f' returns 'None'.
    *)
    let fold_build init f = 
        let rec inner accu accu_list =
            match f accu with
            | None -> accu_list
            | Some new_accu -> inner new_accu (new_accu :: accu_list)
        inner init

(*********************************************************************)

let get_vertical_coords y1 y2 x =
    let rec inner y1 y2 accum =
        if y1 = y2 then
            accum
        else
            inner (y1+1) y2 ((x, y1) :: accum)
    in
    inner y1 y2 []

let get_horizontal_coords x1 x2 y =
    let rec inner x1 x2 accum =
        if x1 = x2 then
            accum
        else
            inner (x1+1) x2 ((x1, y) :: accum)
    in
    inner y1 y2 []

let 