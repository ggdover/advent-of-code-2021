
let input_all_lines file =
    let rec build_list ic lines =
        match input_line ic with
        | exception End_of_file -> lines
        | line -> build_list ic (line::lines)
    in
    let ic = open_in file in
    let result = build_list ic [] in
    List.rev result

module String = struct
    include String
    let split_on_str delim str = Str.split (Str.regexp delim) str
    (*let lsplit2_exn = Base.String.lsplit2_exn*)
end

module List = struct
    include List
    (* Based on the 'fold'/'fold_left' function, except it
       works backwards, starting only from a initial value
       that is used to build up a list of elements of the
       same type as 'init'.
       The function 'f' returns a tuple consisting of:
       1. Value appended to the resulting list and 
          used as the input to the next call to 'f',
          as long as the 2nd element in the tuple is
          true.
       2. Bool, this is the stop condition, determining
          when the "build" call should end.
          Stops when this is set to false.
          The value in first position of the tuple
          will not be appended to the list the same 
          turn when this bool is set to false.
    *)
    let build init f = 
        let rec inner accu accu_list =
            let new_accu, continue = f accu in
            if continue then
                inner new_accu (new_accu :: accu_list)
            else
                accu_list
        inner init

type line_seg_t =
    { x1 : int;  (* Start X-coord *) 
      y1 : int;  (* Start Y-coord *)
      x2 : int;  (* End X-coord *)
      y2 : int } (* End Y-coord *)

(*********************************************)

(*let fold_permutations init list =
*)

let parse_line_seg line_seg =
    let [start_coord; end_coord] = String.split_on_str " -> " line_seg in
    let [x1; y1] = String.split_on_char ',' start_coord in
    let [x2; y2] = String.split_on_char ',' end_coord in 
    { x1 = x1; x2 = x2; y1 = y1; y2 = y2 }

let is_vertical line =
    line.x1 = line.x2

let is_horizontal line =
    line.y1 = line.y2

let is_orthogonal line =
    is_vertical line || is_horizontal line

(* Only keep orthogonal lines (Vertical and horizontal lines) *)
let rec parse_and_filter_lines lines new_lines =
    match lines with
    | [] -> List.rev new_lines
    | line::rem_lines ->
        let line_seg = parse_line_seg line in
        if is_orthogonal line_seg then
            filter_lines rem_lines (line_seg :: new_lines)
        else
            filter_lines rem_lines new_lines

(* Get the list of coordinates of a line segment 
   that is horizontal or vertical. *)
let get_coords line =
    match line with
    | is_horizontal line ->
        let start_x = min line.x1 line.x2 in
        let end_x = max line.x1 line.x2 in
        List.build (start_x-1, line.y1) (fun x -> (x+1, y), x > end_x)
    | is_vertical lines ->
        let start_y = min line.y1 line.y2 in
        let end_y = max line.y1 line.y2 in
        List.build (line.x1, start_y-1) (fun y -> (x, y+1), y > end_y)
    | _ -> 
        raise (Failure ("What is non-orthogonal line doing here????"))



(* Find the coordinates at which two line segments intersect/overlap *)
let find_intersects line1 line2 =    
    match line1 line2 with
    | is_vertical line1 && is_vertical line2 && line1.x1 = line2.x1 -> 
        (* Lines are both vertical and exist in the same column*)

        if line1.y1 < line2.y1 < line1.y2 then
        else if line1.y1 < line2.y2 < line1.y2 then


        let line1_y_start = min line1.y1 line1.y2 in
        let line1_y_end = max line1.y1 line1.y2 in
        
        let line2_y_start = min line2.y1 line2.y2 in
        let line2_y_end = max line2.y1 line2.y2 in

        let overlap_start = max line1_y_start line2_y_start in
        let overlap_end = min line_y_end line2_y_end in

        let overlap_coords = 
            List.build (line1.x1, overlap_start) (fun x, y -> ((x, y+1), y >= overlap_end)) in

        (*List.init overlap_start (fun y -> (line1.x1, y))
        let overlap_coords = get_vertical_coords*)
    | is_horizontal line1 && is_horizontal line2 && line1.y1 = line2.y1 -> 
        (* Lines are both horizontal and exist in the same row *)
        let overlap_start = max line1.x1 line2.x1 in
        let overlap_end = max line1.x2 line2.x2 in

    | line1.x1 = line -> 
        (* Lines are paralell *)
        match line1 line2 with


    | (line1.angle = Vert &&
       line2.x1 < line1.x1 < line2.x2) or 
      (line2.angle = Vert &&
       line1.x1 < line2.x1 < line1.x2) ->
       (* Lines are orthogonal and overlap *)

let part1 lines =
    let orthog_line_segs = parse_and_filter_lines lines in

let () = 
    let lines = input_all_lines "input.txt" in
    part1 lines
